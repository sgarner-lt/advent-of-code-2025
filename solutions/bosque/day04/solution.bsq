namespace Main;

// Advent of Code 2025 Day 4 Part 1 & Part 2 - Paper Roll Accessibility
//
// IMPORTANT: Bosque is a Microsoft Research language with limited stdlib
// This implementation follows the spec but requires a Python wrapper
// for file I/O and execution due to BosqueCore limitations.
//
// Algorithm:
//
// Part 1: Identify accessible paper rolls in a factory grid
//   1. Parse grid from input (@ = paper roll, . = empty space)
//   2. For each roll (@), check all 8 adjacent positions (N, S, E, W, NE, NW, SE, SW)
//   3. Count adjacent rolls (boundary cells have fewer neighbors)
//   4. Roll is accessible if adjacent_count < 4
//   5. Return count of accessible rolls and grid visualization
//
// Part 2: Iteratively remove accessible rolls
//   1. Start with initial grid
//   2. Loop: identify accessible rolls, remove batch, update grid
//   3. Exit loop when no accessible rolls found
//   4. Return total count of removed rolls
//
// Example:
// Input grid (10x10 sample):
//   @.@
//   .@.
//   @.@
// Center roll at (1,1) has 4 adjacent rolls -> inaccessible
// Corner rolls have fewer neighbors -> accessible (if < 4 adjacent)
//
// Grid visualization:
//   - 'x' = accessible roll
//   - '@' = inaccessible roll
//   - '.' = empty space
//
// Expected results:
// - Sample input (input-sample.txt): Part 1 = 13, Part 2 = 43
// - Real input (input.txt): Part 1 = <Redacted>, Part 2 = <Redacted>

// Parse grid from multi-line input string
// Returns a 2D list of characters
//
// Arguments:
// - input: Multi-line string containing grid data
//
// Returns: List of Lists representing the grid
function parseGrid(input: String): List<List<String>> {
    var lines = String::split(input, "\n");
    var grid = List::create<List<String>>();
    var i = 0i;

    while(i < List::size<String>(lines)) {
        var line = List::get<String>(lines, i);
        var trimmed = String::trim(line);

        // Skip empty lines
        if(String::length(trimmed) > 0i) {
            var row = List::create<String>();
            var j = 0i;

            // Convert line to list of characters
            while(j < String::length(trimmed)) {
                var char = String::substring(trimmed, j, j + 1i);
                row = List::add<String>(row, char);
                j = j + 1i;
            }

            grid = List::add<List<String>>(grid, row);
        }

        i = i + 1i;
    }

    return grid;
}

// Count adjacent rolls (@ symbols) in all 8 directions
// Handles boundary conditions for edge and corner cells
//
// Arguments:
// - grid: 2D list representing the grid
// - row: Row index of the cell
// - col: Column index of the cell
//
// Returns: Count of adjacent @ symbols (0-8)
function countAdjacentRolls(grid: List<List<String>>, row: Int, col: Int): Int {
    var count = 0i;
    var gridHeight = List::size<List<String>>(grid);

    if(gridHeight == 0i) {
        return 0i;
    }

    var firstRow = List::get<List<String>>(grid, 0i);
    var gridWidth = List::size<String>(firstRow);

    // 8 directions: N, S, E, W, NE, NW, SE, SW
    var directions = List::create<{dr: Int, dc: Int}>();
    directions = List::add<{dr: Int, dc: Int}>(directions, {dr: -1i, dc: 0i});  // N
    directions = List::add<{dr: Int, dc: Int}>(directions, {dr: 1i, dc: 0i});   // S
    directions = List::add<{dr: Int, dc: Int}>(directions, {dr: 0i, dc: -1i});  // W
    directions = List::add<{dr: Int, dc: Int}>(directions, {dr: 0i, dc: 1i});   // E
    directions = List::add<{dr: Int, dc: Int}>(directions, {dr: -1i, dc: -1i}); // NW
    directions = List::add<{dr: Int, dc: Int}>(directions, {dr: -1i, dc: 1i});  // NE
    directions = List::add<{dr: Int, dc: Int}>(directions, {dr: 1i, dc: -1i});  // SW
    directions = List::add<{dr: Int, dc: Int}>(directions, {dr: 1i, dc: 1i});   // SE

    var i = 0i;
    while(i < List::size<{dr: Int, dc: Int}>(directions)) {
        var dir = List::get<{dr: Int, dc: Int}>(directions, i);
        var newRow = row + dir.dr;
        var newCol = col + dir.dc;

        // Check boundaries
        if(newRow >= 0i && newRow < gridHeight && newCol >= 0i && newCol < gridWidth) {
            var targetRow = List::get<List<String>>(grid, newRow);
            var cell = List::get<String>(targetRow, newCol);

            if(String::equals(cell, "@")) {
                count = count + 1i;
            }
        }

        i = i + 1i;
    }

    return count;
}

// Identify accessible rolls in the grid
// Returns a tuple with count and list of accessible positions
//
// Arguments:
// - grid: 2D list representing the grid
//
// Returns: Tuple with count and list of {row, col} positions
function findAccessibleRolls(grid: List<List<String>>): {count: Int, positions: List<{row: Int, col: Int}>} {
    var count = 0i;
    var positions = List::create<{row: Int, col: Int}>();
    var gridHeight = List::size<List<String>>(grid);

    var i = 0i;
    while(i < gridHeight) {
        var row = List::get<List<String>>(grid, i);
        var rowWidth = List::size<String>(row);

        var j = 0i;
        while(j < rowWidth) {
            var cell = List::get<String>(row, j);

            // Check if current cell is a roll
            if(String::equals(cell, "@")) {
                var adjacentCount = countAdjacentRolls(grid, i, j);

                // Accessible if fewer than 4 adjacent rolls
                if(adjacentCount < 4i) {
                    count = count + 1i;
                    positions = List::add<{row: Int, col: Int}>(positions, {row: i, col: j});
                }
            }

            j = j + 1i;
        }

        i = i + 1i;
    }

    return {count: count, positions: positions};
}

// Create grid visualization marking accessible and inaccessible rolls
// Returns a string with '\n' separating rows
//
// Arguments:
// - grid: Original 2D grid
// - accessiblePositions: List of accessible position tuples
//
// Returns: Formatted grid string with x/@/. markers
function createVisualization(grid: List<List<String>>, accessiblePositions: List<{row: Int, col: Int}>): String {
    var result = "";
    var gridHeight = List::size<List<String>>(grid);

    var i = 0i;
    while(i < gridHeight) {
        var row = List::get<List<String>>(grid, i);
        var rowWidth = List::size<String>(row);
        var rowStr = "";

        var j = 0i;
        while(j < rowWidth) {
            var cell = List::get<String>(row, j);

            if(String::equals(cell, "@")) {
                // Check if this position is in accessible list
                var isAccessible = false;
                var k = 0i;
                while(k < List::size<{row: Int, col: Int}>(accessiblePositions)) {
                    var pos = List::get<{row: Int, col: Int}>(accessiblePositions, k);
                    if(pos.row == i && pos.col == j) {
                        isAccessible = true;
                    }
                    k = k + 1i;
                }

                if(isAccessible) {
                    rowStr = String::concat(rowStr, "x");
                } else {
                    rowStr = String::concat(rowStr, "@");
                }
            } else {
                rowStr = String::concat(rowStr, cell);
            }

            j = j + 1i;
        }

        result = String::concat(result, rowStr);
        if(i < gridHeight - 1i) {
            result = String::concat(result, "\n");
        }

        i = i + 1i;
    }

    return result;
}

// Remove rolls from the grid at specified positions
// Returns a new grid with removed positions replaced by '.'
//
// Arguments:
// - grid: Original 2D grid
// - positions: List of {row, col} positions to remove
//
// Returns: New grid with rolls removed
function removeRolls(grid: List<List<String>>, positions: List<{row: Int, col: Int}>): List<List<String>> {
    var newGrid = List::create<List<String>>();
    var gridHeight = List::size<List<String>>(grid);

    var i = 0i;
    while(i < gridHeight) {
        var row = List::get<List<String>>(grid, i);
        var rowWidth = List::size<String>(row);
        var newRow = List::create<String>();

        var j = 0i;
        while(j < rowWidth) {
            var cell = List::get<String>(row, j);

            // Check if this position should be removed
            var shouldRemove = false;
            var k = 0i;
            while(k < List::size<{row: Int, col: Int}>(positions)) {
                var pos = List::get<{row: Int, col: Int}>(positions, k);
                if(pos.row == i && pos.col == j) {
                    shouldRemove = true;
                }
                k = k + 1i;
            }

            if(shouldRemove) {
                newRow = List::add<String>(newRow, ".");
            } else {
                newRow = List::add<String>(newRow, cell);
            }

            j = j + 1i;
        }

        newGrid = List::add<List<String>>(newGrid, newRow);
        i = i + 1i;
    }

    return newGrid;
}

// Solve Part 2: Iteratively remove accessible rolls
// Returns total count of removed rolls across all iterations
//
// Arguments:
// - grid: Initial 2D grid
//
// Returns: Total count of removed rolls
function solvePart2Loop(grid: List<List<String>>, totalRemoved: Int): Int {
    // Identify all accessible rolls in current grid state
    var result = findAccessibleRolls(grid);

    // If no accessible rolls found, we're done
    if(result.count == 0i) {
        return totalRemoved;
    }

    // Count removed rolls in this iteration
    var removedCount = result.count;
    var newTotal = totalRemoved + removedCount;

    // Remove all accessible rolls (batch removal)
    var newGrid = removeRolls(grid, result.positions);

    // Continue with next iteration
    return solvePart2Loop(newGrid, newTotal);
}

// Main solve function that processes the grid and returns results
//
// Arguments:
// - input: Multi-line string containing grid data
//
// Returns: Tuple with part1 answer, part2 answer, and grid visualization
function solve(input: String): {part1: Int, part2: Int, grid: String} {
    var grid = parseGrid(input);

    // Part 1: Initial accessible rolls
    var result = findAccessibleRolls(grid);
    var visualization = createVisualization(grid, result.positions);

    // Part 2: Total removed rolls through iterative removal
    var part2Count = solvePart2Loop(grid, 0i);

    return {part1: result.count, part2: part2Count, grid: visualization};
}

// Main entry point
// Note: File I/O in Bosque is experimental - requires Python wrapper
entrypoint function main(args: List<String>): Int {
    var inputContent = "";

    // Read file path from command-line arguments
    if(List::size<String>(args) > 1i) {
        var filePath = List::get<String>(args, 1i);

        // WORKAROUND: Bosque file I/O is not available
        // The Python runner wrapper handles file reading and execution
        try {
            inputContent = Environment::readFile(filePath);
        }
        catch {
            // Fallback: try reading from stdin
            inputContent = Console::readAll();
        }
    }

    var result = solve(inputContent);

    // Escape newlines in grid visualization for JSON
    var escapedGrid = String::replace(result.grid, "\n", "\\n");

    var output = String::concat(
        "{\"part1\": ",
        Int::toString(result.part1),
        ", \"part2\": ",
        Int::toString(result.part2),
        ", \"additional-info\": {\"grid\": \"",
        escapedGrid,
        "\"}}"
    );
    Console::writeLine(output);

    return 0i;
}

// === UNIT TESTS (14 tests) ===

// Test 1: Parse simple 2x2 grid
function test_parseGridSimple(): Bool {
    var input = "@.\n.@";
    var grid = parseGrid(input);
    _assert(List::size<List<String>>(grid) == 2i);
    var row1 = List::get<List<String>>(grid, 0i);
    _assert(List::size<String>(row1) == 2i);
    return true;
}

// Test 2: Count adjacent rolls for corner cell (should have fewer neighbors)
function test_countAdjacentCorner(): Bool {
    var input = "@@@\n@@@\n@@@";
    var grid = parseGrid(input);
    // Top-left corner (0,0) has 3 neighbors: (0,1), (1,0), (1,1)
    var count = countAdjacentRolls(grid, 0i, 0i);
    _assert(count == 3i);
    return true;
}

// Test 3: Count adjacent rolls for edge cell
function test_countAdjacentEdge(): Bool {
    var input = "@@@\n@@@\n@@@";
    var grid = parseGrid(input);
    // Top edge center (0,1) has 5 neighbors
    var count = countAdjacentRolls(grid, 0i, 1i);
    _assert(count == 5i);
    return true;
}

// Test 4: Count adjacent rolls for interior cell (all 8 neighbors)
function test_countAdjacentInterior(): Bool {
    var input = "@@@\n@@@\n@@@";
    var grid = parseGrid(input);
    // Center cell (1,1) has 8 neighbors
    var count = countAdjacentRolls(grid, 1i, 1i);
    _assert(count == 8i);
    return true;
}

// Test 5: Accessibility rule - roll with < 4 neighbors is accessible
function test_accessibilityRule(): Bool {
    var input = "@@.\n...";
    var grid = parseGrid(input);
    var result = findAccessibleRolls(grid);
    // Both rolls have < 4 neighbors, so both are accessible
    _assert(result.count == 2i);
    return true;
}

// Test 6: Grid visualization marks accessible as 'x'
function test_visualizationFormat(): Bool {
    var input = "@@.\n...";
    var grid = parseGrid(input);
    var result = findAccessibleRolls(grid);
    var viz = createVisualization(grid, result.positions);
    // Both @ should become 'x' (accessible)
    _assert(String::contains(viz, "x"));
    return true;
}

// Test 7: Empty grid handling
function test_emptyGrid(): Bool {
    var input = "";
    var grid = parseGrid(input);
    var result = findAccessibleRolls(grid);
    _assert(result.count == 0i);
    return true;
}

// Test 8: Sample input produces expected answer (13)
function test_sampleInputPart1(): Bool {
    // Note: This is a simplified test - actual sample would be larger
    var sample = ".@.\n@@@\n.@.";
    var result = solve(sample);
    // In this 3x3 with center surrounded by 4 rolls, center is inaccessible
    // The 4 edge rolls each have 3 neighbors (< 4), so all 4 are accessible
    _assert(result.part1 == 4i);
    return true;
}

// Part 2 Tests

// Test 9: Remove rolls function
function test_removeRolls(): Bool {
    var input = "@@.\n@..";
    var grid = parseGrid(input);
    var positions = List::create<{row: Int, col: Int}>();
    positions = List::add<{row: Int, col: Int}>(positions, {row: 0i, col: 0i});
    positions = List::add<{row: Int, col: Int}>(positions, {row: 0i, col: 1i});
    var newGrid = removeRolls(grid, positions);

    var row0 = List::get<List<String>>(newGrid, 0i);
    var cell00 = List::get<String>(row0, 0i);
    var cell01 = List::get<String>(row0, 1i);
    _assert(String::equals(cell00, "."));
    _assert(String::equals(cell01, "."));
    return true;
}

// Test 10: Part 2 single iteration (all rolls accessible)
function test_part2SingleIteration(): Bool {
    var input = "@..\n.@.\n..@";
    var result = solve(input);
    // All 3 rolls are accessible in first iteration (0-1 neighbors each)
    _assert(result.part2 == 3i);
    return true;
}

// Test 11: Part 2 preserves Part 1 result
function test_part2PreservesPart1(): Bool {
    var sample = ".@.\n@@@\n.@.";
    var result = solve(sample);
    // Part 1 should still be 4
    _assert(result.part1 == 4i);
    return true;
}

// Test 12: Part 2 empty grid
function test_part2EmptyGrid(): Bool {
    var input = "";
    var result = solve(input);
    _assert(result.part2 == 0i);
    return true;
}

// Test 13: Part 2 iteration termination
function test_part2IterationTermination(): Bool {
    var input = ".....\n.@@@.\n.@@@.\n.@@@.\n.....";
    var result = solve(input);
    // Should remove some rolls but stop when none are accessible
    _assert(result.part2 > 0i);
    _assert(result.part2 <= 9i);
    return true;
}

// Test 14: Full sample validation
function test_fullSampleValidation(): Bool {
    // This would test the full sample input if available in Bosque
    // For now, just verify the solve function returns valid structure
    var sample = ".@.\n@@@\n.@.";
    var result = solve(sample);
    _assert(result.part1 >= 0i);
    _assert(result.part2 >= 0i);
    return true;
}

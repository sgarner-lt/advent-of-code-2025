namespace Main;

// Advent of Code 2025 Day 4 Part 1 - Paper Roll Accessibility
//
// IMPORTANT: Bosque is a Microsoft Research language with limited stdlib
// This implementation follows the spec but requires a Python wrapper
// for file I/O and execution due to BosqueCore limitations.
//
// Algorithm:
// Part 1: Identify accessible paper rolls in a factory grid
//   1. Parse grid from input (@ = paper roll, . = empty space)
//   2. For each roll (@), check all 8 adjacent positions (N, S, E, W, NE, NW, SE, SW)
//   3. Count adjacent rolls (boundary cells have fewer neighbors)
//   4. Roll is accessible if adjacent_count < 4
//   5. Return count of accessible rolls and grid visualization
//
// Part 2: Not implemented (null)
//
// Example:
// Input grid (3x3):
//   @.@
//   .@.
//   @.@
// Center roll at (1,1) has 4 adjacent rolls -> inaccessible
// Corner rolls have fewer neighbors -> accessible (if < 4 adjacent)
//
// Grid visualization:
//   - 'x' = accessible roll
//   - '@' = inaccessible roll
//   - '.' = empty space
//
// Expected results:
// - Sample input (input-sample.txt): Part 1 = 13, Part 2 = null
// - Real input (input.txt): Part 1 = <Redacted>, Part 2 = null

// Parse grid from multi-line input string
// Returns a 2D list of characters
//
// Arguments:
// - input: Multi-line string containing grid data
//
// Returns: List of Lists representing the grid
function parseGrid(input: String): List<List<String>> {
    var lines = String::split(input, "\n");
    var grid = List::create<List<String>>();
    var i = 0i;

    while(i < List::size<String>(lines)) {
        var line = List::get<String>(lines, i);
        var trimmed = String::trim(line);

        // Skip empty lines
        if(String::length(trimmed) > 0i) {
            var row = List::create<String>();
            var j = 0i;

            // Convert line to list of characters
            while(j < String::length(trimmed)) {
                var char = String::substring(trimmed, j, j + 1i);
                row = List::add<String>(row, char);
                j = j + 1i;
            }

            grid = List::add<List<String>>(grid, row);
        }

        i = i + 1i;
    }

    return grid;
}

// Count adjacent rolls (@ symbols) in all 8 directions
// Handles boundary conditions for edge and corner cells
//
// Arguments:
// - grid: 2D list representing the grid
// - row: Row index of the cell
// - col: Column index of the cell
//
// Returns: Count of adjacent @ symbols (0-8)
function countAdjacentRolls(grid: List<List<String>>, row: Int, col: Int): Int {
    var count = 0i;
    var gridHeight = List::size<List<String>>(grid);

    if(gridHeight == 0i) {
        return 0i;
    }

    var firstRow = List::get<List<String>>(grid, 0i);
    var gridWidth = List::size<String>(firstRow);

    // 8 directions: N, S, E, W, NE, NW, SE, SW
    var directions = List::create<{dr: Int, dc: Int}>();
    directions = List::add<{dr: Int, dc: Int}>(directions, {dr: -1i, dc: 0i});  // N
    directions = List::add<{dr: Int, dc: Int}>(directions, {dr: 1i, dc: 0i});   // S
    directions = List::add<{dr: Int, dc: Int}>(directions, {dr: 0i, dc: -1i});  // W
    directions = List::add<{dr: Int, dc: Int}>(directions, {dr: 0i, dc: 1i});   // E
    directions = List::add<{dr: Int, dc: Int}>(directions, {dr: -1i, dc: -1i}); // NW
    directions = List::add<{dr: Int, dc: Int}>(directions, {dr: -1i, dc: 1i});  // NE
    directions = List::add<{dr: Int, dc: Int}>(directions, {dr: 1i, dc: -1i});  // SW
    directions = List::add<{dr: Int, dc: Int}>(directions, {dr: 1i, dc: 1i});   // SE

    var i = 0i;
    while(i < List::size<{dr: Int, dc: Int}>(directions)) {
        var dir = List::get<{dr: Int, dc: Int}>(directions, i);
        var newRow = row + dir.dr;
        var newCol = col + dir.dc;

        // Check boundaries
        if(newRow >= 0i && newRow < gridHeight && newCol >= 0i && newCol < gridWidth) {
            var targetRow = List::get<List<String>>(grid, newRow);
            var cell = List::get<String>(targetRow, newCol);

            if(String::equals(cell, "@")) {
                count = count + 1i;
            }
        }

        i = i + 1i;
    }

    return count;
}

// Identify accessible rolls in the grid
// Returns a tuple with count and list of accessible positions
//
// Arguments:
// - grid: 2D list representing the grid
//
// Returns: Tuple with count and list of {row, col} positions
function findAccessibleRolls(grid: List<List<String>>): {count: Int, positions: List<{row: Int, col: Int}>} {
    var count = 0i;
    var positions = List::create<{row: Int, col: Int}>();
    var gridHeight = List::size<List<String>>(grid);

    var i = 0i;
    while(i < gridHeight) {
        var row = List::get<List<String>>(grid, i);
        var rowWidth = List::size<String>(row);

        var j = 0i;
        while(j < rowWidth) {
            var cell = List::get<String>(row, j);

            // Check if current cell is a roll
            if(String::equals(cell, "@")) {
                var adjacentCount = countAdjacentRolls(grid, i, j);

                // Accessible if fewer than 4 adjacent rolls
                if(adjacentCount < 4i) {
                    count = count + 1i;
                    positions = List::add<{row: Int, col: Int}>(positions, {row: i, col: j});
                }
            }

            j = j + 1i;
        }

        i = i + 1i;
    }

    return {count: count, positions: positions};
}

// Create grid visualization marking accessible and inaccessible rolls
// Returns a string with '\n' separating rows
//
// Arguments:
// - grid: Original 2D grid
// - accessiblePositions: List of accessible position tuples
//
// Returns: Formatted grid string with x/@/. markers
function createVisualization(grid: List<List<String>>, accessiblePositions: List<{row: Int, col: Int}>): String {
    var result = "";
    var gridHeight = List::size<List<String>>(grid);

    var i = 0i;
    while(i < gridHeight) {
        var row = List::get<List<String>>(grid, i);
        var rowWidth = List::size<String>(row);
        var rowStr = "";

        var j = 0i;
        while(j < rowWidth) {
            var cell = List::get<String>(row, j);

            if(String::equals(cell, "@")) {
                // Check if this position is in accessible list
                var isAccessible = false;
                var k = 0i;
                while(k < List::size<{row: Int, col: Int}>(accessiblePositions)) {
                    var pos = List::get<{row: Int, col: Int}>(accessiblePositions, k);
                    if(pos.row == i && pos.col == j) {
                        isAccessible = true;
                    }
                    k = k + 1i;
                }

                if(isAccessible) {
                    rowStr = String::concat(rowStr, "x");
                } else {
                    rowStr = String::concat(rowStr, "@");
                }
            } else {
                rowStr = String::concat(rowStr, cell);
            }

            j = j + 1i;
        }

        result = String::concat(result, rowStr);
        if(i < gridHeight - 1i) {
            result = String::concat(result, "\n");
        }

        i = i + 1i;
    }

    return result;
}

// Main solve function that processes the grid and returns results
//
// Arguments:
// - input: Multi-line string containing grid data
//
// Returns: Tuple with part1 answer, part2 (null), and grid visualization
function solve(input: String): {part1: Int, part2: Int?, grid: String} {
    var grid = parseGrid(input);
    var result = findAccessibleRolls(grid);
    var visualization = createVisualization(grid, result.positions);

    return {part1: result.count, part2: none, grid: visualization};
}

// Main entry point
// Note: File I/O in Bosque is experimental - requires Python wrapper
entrypoint function main(args: List<String>): Int {
    var inputContent = "";

    // Read file path from command-line arguments
    if(List::size<String>(args) > 1i) {
        var filePath = List::get<String>(args, 1i);

        // WORKAROUND: Bosque file I/O is not available
        // The Python runner wrapper handles file reading and execution
        try {
            inputContent = Environment::readFile(filePath);
        }
        catch {
            // Fallback: try reading from stdin
            inputContent = Console::readAll();
        }
    }

    var result = solve(inputContent);

    // Output JSON format for cross-language validation
    var part2Str = "null";

    // Escape newlines in grid visualization for JSON
    var escapedGrid = String::replace(result.grid, "\n", "\\n");

    var output = String::concat(
        "{\"part1\": ",
        Int::toString(result.part1),
        ", \"part2\": ",
        part2Str,
        ", \"additional-info\": {\"grid\": \"",
        escapedGrid,
        "\"}}"
    );
    Console::writeLine(output);

    return 0i;
}

// === UNIT TESTS (8 tests) ===

// Test 1: Parse simple 2x2 grid
function test_parseGridSimple(): Bool {
    var input = "@.\n.@";
    var grid = parseGrid(input);
    _assert(List::size<List<String>>(grid) == 2i);
    var row1 = List::get<List<String>>(grid, 0i);
    _assert(List::size<String>(row1) == 2i);
    return true;
}

// Test 2: Count adjacent rolls for corner cell (should have fewer neighbors)
function test_countAdjacentCorner(): Bool {
    var input = "@@@\n@@@\n@@@";
    var grid = parseGrid(input);
    // Top-left corner (0,0) has 3 neighbors: (0,1), (1,0), (1,1)
    var count = countAdjacentRolls(grid, 0i, 0i);
    _assert(count == 3i);
    return true;
}

// Test 3: Count adjacent rolls for edge cell
function test_countAdjacentEdge(): Bool {
    var input = "@@@\n@@@\n@@@";
    var grid = parseGrid(input);
    // Top edge center (0,1) has 5 neighbors
    var count = countAdjacentRolls(grid, 0i, 1i);
    _assert(count == 5i);
    return true;
}

// Test 4: Count adjacent rolls for interior cell (all 8 neighbors)
function test_countAdjacentInterior(): Bool {
    var input = "@@@\n@@@\n@@@";
    var grid = parseGrid(input);
    // Center cell (1,1) has 8 neighbors
    var count = countAdjacentRolls(grid, 1i, 1i);
    _assert(count == 8i);
    return true;
}

// Test 5: Accessibility rule - roll with < 4 neighbors is accessible
function test_accessibilityRule(): Bool {
    var input = "@@.\n...";
    var grid = parseGrid(input);
    var result = findAccessibleRolls(grid);
    // Both rolls have < 4 neighbors, so both are accessible
    _assert(result.count == 2i);
    return true;
}

// Test 6: Grid visualization marks accessible as 'x'
function test_visualizationFormat(): Bool {
    var input = "@@.\n...";
    var grid = parseGrid(input);
    var result = findAccessibleRolls(grid);
    var viz = createVisualization(grid, result.positions);
    // Both @ should become 'x' (accessible)
    _assert(String::contains(viz, "x"));
    return true;
}

// Test 7: Empty grid handling
function test_emptyGrid(): Bool {
    var input = "";
    var grid = parseGrid(input);
    var result = findAccessibleRolls(grid);
    _assert(result.count == 0i);
    return true;
}

// Test 8: Sample input produces expected answer (13)
function test_sampleInputComplete(): Bool {
    // Note: This is a simplified test - actual sample would be larger
    var sample = ".@.\n@@@\n.@.";
    var result = solve(sample);
    // In this 3x3 with center surrounded by 4 rolls, center is inaccessible
    // The 4 edge rolls each have 3 neighbors (< 4), so all 4 are accessible
    _assert(result.part1 == 4i);
    _assert(result.part2 == none);
    return true;
}
